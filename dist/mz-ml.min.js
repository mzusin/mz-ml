/* 
mzMl v1.0.0
A collection of TypeScript-based ML helpers.
https://github.com/mzusin/mz-ml
Copyright (c) 2023-present, Miriam Zusin          
*/
(()=>{var b=Object.defineProperty;var m=Object.getOwnPropertySymbols;var M=Object.prototype.hasOwnProperty,S=Object.prototype.propertyIsEnumerable;var a=(e,t,i)=>t in e?b(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,f=(e,t)=>{for(var i in t||(t={}))M.call(t,i)&&a(e,i,t[i]);if(m)for(var i of m(t))S.call(t,i)&&a(e,i,t[i]);return e};var z=(e,t)=>{for(var i in t)b(e,i,{get:t[i],enumerable:!0})};var h=(e,t,i)=>(a(e,typeof t!="symbol"?t+"":t,i),i);var c={};z(c,{LinearRegression:()=>p});var p=class{constructor(t){h(this,"options");h(this,"m");h(this,"b");this.options=t,this.options.points=[...this.options.points],this.m=0,this.b=0}shuffle(){for(let t=this.options.points.length-1;t>0;t--){let i=Math.floor(Math.random()*(t+1));[this.options.points[t],this.options.points[i]]=[this.options.points[i],this.options.points[t]]}}gradientDescent(t){let i=0,n=0,s=t.length;for(let[l,d]of t){let g=this.m*l+this.b,u=d-g;i+=-2*l*u,n+=-2*u}let o=this.m-this.options.learningRate/s*i,r=this.b-this.options.learningRate/s*n;return[o,r]}getBatchSize(){var t;switch(this.options.optimization){case 1:return 1;case 2:return(t=this.options.batchSize)!=null?t:this.options.points.length;default:return this.options.points.length}}train(){let t=this.getBatchSize();for(let i=0;i<this.options.epochs;i++){this.options.shuffle&&this.shuffle();for(let n=0;n<this.options.points.length;n+=t){let s=this.options.points.slice(n,n+t),[o,r]=this.gradientDescent(s);typeof this.options.epochsCallback=="function"&&this.options.epochsCallback(i,this.options.epochs,o,r),this.m=o,this.b=r}}return[this.m,this.b]}predict(t){return this.m*t+this.b}};var B=f({},c);window.mzMl=window.mzMl||B;})();
//# sourceMappingURL=mz-ml.min.js.map
