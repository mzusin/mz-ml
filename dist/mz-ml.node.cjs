/* 
mzMl v1.0.0
A collection of TypeScript-based ML helpers.
https://github.com/mzusin/mz-ml
Copyright (c) 2023-present, Miriam Zusin          
*/
var g=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var S=Object.prototype.hasOwnProperty;var f=Math.pow,z=(h,e,t)=>e in h?g(h,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[e]=t;var v=(h,e)=>{for(var t in e)g(h,t,{get:e[t],enumerable:!0})},V=(h,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of w(e))!S.call(h,i)&&i!==t&&g(h,i,{get:()=>e[i],enumerable:!(s=d(e,i))||s.enumerable});return h};var x=h=>V(g({},"__esModule",{value:!0}),h);var l=(h,e,t)=>(z(h,typeof e!="symbol"?e+"":e,t),t);var y={};v(y,{LinearRegression:()=>b});module.exports=x(y);var b=class{constructor(e){l(this,"options");l(this,"weights");l(this,"bias");l(this,"features");l(this,"labels");l(this,"n");l(this,"batchSize");l(this,"pearson",()=>{if(this.features.length<=0||this.labels.length<=0)return[];let e=[],t=this.labels.reduce((s,i)=>s+i,0)/this.labels.length;for(let s=0;s<this.n;s++){let i=0,n=0,o=0,r=this.features.map(a=>a[s]),u=r.reduce((a,c)=>a+c,0)/r.length;for(let a=0;a<this.features.length;a++){let c=this.features[a][s],m=this.labels[a];i+=(c-u)*(m-t),n+=f(c-u,2),o+=f(m-t,2)}e.push(n===0||o===0?0:i/Math.sqrt(n*o))}return e});var t;if(this.options=e,this.features=[...this.options.features],this.labels=[...this.options.labels],this.n=this.features.length>0?this.features[0].length:0,!this.validateInput())throw new Error("The input is not valid. Number of features should match the number of labels, and all features should have the same size.");this.weights=b.initZeroArray(this.n),this.weights.length=this.n,this.weights.fill(0),this.bias=0,this.batchSize=(t=this.options.batchSize)!=null?t:this.features.length}validateInput(){if(this.features.length<=0||this.features.length!==this.labels.length)return!1;let e=this.features[0].length;for(let t of this.features)if(t.length!==e)return!1;return!0}static initZeroArray(e){let t=[];return t.length=e,t.fill(0),t}shuffle(){let e=[];for(let t=0;t<this.n;t++)e.push(t);for(let t=this.features.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[e[t],e[s]]=[e[s],e[t]]}for(let t=this.features.length-1;t>0;t--)[this.features[t],this.features[e[t]]]=[this.features[e[t]],this.features[t]],[this.labels[t],this.labels[e[t]]]=[this.labels[e[t]],this.labels[t]]}gradientDescent(e,t){let s=b.initZeroArray(this.n),i=0;for(let r=0;r<e.length;r++){let u=e[r],a=t[r],c=this.predict(u),m=a-c;for(let p=0;p<this.n;p++)s[p]+=-2*u[p]*m;i+=-2*m}let n=[];for(let r=0;r<this.weights.length;r++){let a=this.weights[r]-this.options.learningRate/this.batchSize*s[r];n.push(a)}let o=this.bias-this.options.learningRate/this.batchSize*i;return[n,o]}fit(){let e=performance.now();for(let t=0;t<this.options.epochs;t++){this.options.shuffle&&this.shuffle();for(let s=0;s<this.features.length;s+=this.batchSize){let i=this.features.slice(s,s+this.batchSize),n=this.labels.slice(s,s+this.batchSize),[o,r]=this.gradientDescent(i,n);if(typeof this.options.epochsCallback=="function"){let u=performance.now();this.options.epochsCallback({epoch:t,epochsCount:this.options.epochs,newWeights:o,newBias:r,time:u-e})}this.weights=o,this.bias=r}}return[this.weights,this.bias]}predict(e,t){if(e.length!==this.weights.length)throw new Error("Number of features does not match the number of weights.");let s=performance.now(),i=this.bias;for(let n=0;n<e.length;n++)i+=e[n]*this.weights[n];return t&&console.log(`Prediction = ${i}, ${performance.now()-s} ms`),i}predictBatch(e,t){let s=[],i=performance.now();for(let n of e)s.push(this.predict(n));return t&&console.log(`Predictions = ${s}, ${performance.now()-i} ms`),s}rSquared(){let e=0,t=0,s=this.labels.length<=0?0:this.labels.reduce((i,n)=>i+n)/this.labels.length;for(let i=0;i<this.features.length;i++){let n=this.labels[i],o=this.predict(this.features[i]);e+=f(n-o,2),t+=f(n-s,2)}return 1-e/t}meanSquaredError(){if(this.features.length<=0)return 0;let e=0;for(let t=0;t<this.features.length;t++){let s=this.labels[t],i=this.predict(this.features[t]);e+=f(s-i,2)}return e/=this.features.length,e}};0&&(module.exports={LinearRegression});
//# sourceMappingURL=mz-ml.node.cjs.map
