/* 
mzMl v1.0.0
A collection of TypeScript-based ML helpers.
https://github.com/mzusin/mz-ml
Copyright (c) 2023-present, Miriam Zusin          
*/
var m=Object.defineProperty;var c=Math.pow,d=(f,e,t)=>e in f?m(f,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):f[e]=t;var l=(f,e,t)=>(d(f,typeof e!="symbol"?e+"":e,t),t);var g=class{constructor(e){l(this,"options");l(this,"weights");l(this,"bias");l(this,"features");l(this,"labels");l(this,"n");l(this,"batchSize");l(this,"pearson",()=>{if(this.features.length<=0||this.labels.length<=0)return[];let e=[],t=this.labels.reduce((s,i)=>s+i,0)/this.labels.length;for(let s=0;s<this.n;s++){let i=0,h=0,a=0,n=this.features.map(r=>r[s]),o=n.reduce((r,u)=>r+u,0)/n.length;for(let r=0;r<this.features.length;r++){let u=this.features[r][s],b=this.labels[r];i+=(u-o)*(b-t),h+=c(u-o,2),a+=c(b-t,2)}e.push(h===0||a===0?0:i/Math.sqrt(h*a))}return e});var t;this.options=e,this.features=[...this.options.features],this.labels=[...this.options.labels],this.n=this.features.length>0?this.features[0].length:0,this.weights=g.initZeroArray(this.n),this.weights.length=this.n,this.weights.fill(0),this.bias=0,this.batchSize=(t=this.options.batchSize)!=null?t:this.features.length}static initZeroArray(e){let t=[];return t.length=e,t.fill(0),t}shuffle(){let e=[];for(let t=0;t<this.n;t++)e.push(t);for(let t=this.features.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[e[t],e[s]]=[e[s],e[t]]}for(let t=this.features.length-1;t>0;t--)[this.features[t],this.features[e[t]]]=[this.features[e[t]],this.features[t]],[this.labels[t],this.labels[e[t]]]=[this.labels[e[t]],this.labels[t]]}gradientDescent(e,t){let s=g.initZeroArray(this.n),i=0;for(let n=0;n<e.length;n++){let o=e[n],r=t[n],u=this.predict(o),b=r-u;for(let p=0;p<this.n;p++)s[p]+=-2*o[p]*b;i+=-2*b}let h=[];for(let n=0;n<this.weights.length;n++){let r=this.weights[n]-this.options.learningRate/this.batchSize*s[n];h.push(r)}let a=this.bias-this.options.learningRate/this.batchSize*i;return[h,a]}fit(){for(let e=0;e<this.options.epochs;e++){this.options.shuffle&&this.shuffle();for(let t=0;t<this.features.length;t+=this.batchSize){let s=this.features.slice(t,t+this.batchSize),i=this.labels.slice(t,t+this.batchSize),[h,a]=this.gradientDescent(s,i);typeof this.options.epochsCallback=="function"&&this.options.epochsCallback(e,this.options.epochs,h,a),this.weights=h,this.bias=a}}return[this.weights,this.bias]}predict(e){if(e.length!==this.weights.length)throw new Error("Number of features does not match the number of weights.");let t=this.bias;for(let s=0;s<e.length;s++)t+=e[s]*this.weights[s];return t}predictBatch(e){let t=[];for(let s of e)t.push(this.predict(s));return t}rSquared(){let e=0,t=0,s=this.labels.length<=0?0:this.labels.reduce((i,h)=>i+h)/this.labels.length;for(let i=0;i<this.features.length;i++){let h=this.labels[i],a=this.predict(this.features[i]);e+=c(h-a,2),t+=c(h-s,2)}return 1-e/t}meanSquaredError(){if(this.features.length<=0)return 0;let e=0;for(let t=0;t<this.features.length;t++){let s=this.labels[t],i=this.predict(this.features[t]);e+=c(s-i,2)}return e/=this.features.length,e}};export{g as LinearRegression};
//# sourceMappingURL=mz-ml.esm.js.map
